---
title: "안드로이드 Room"
excerpt: "SQLite를 보다 세련되게 활용하는 Room에 대해 알아보자"
toc: true
toc_sticky: true
categories: [App]
tags: [app, android, room, kotlin]
use_math: true
---

## App database
앱 내부 데이터베이스에 데이터를 저장하는 방법은 크게 `SharedPreferences`와 `SQLite`가 있다. 저장하려는 데이터가 비교적 작은 경우(자동로그인 유무, 설정 값)에는 주로 `SharedPreferences`로 관리하며 반복적이거나 구조화된 데이터는 `SQLite`로 관리한다. 이 포스트에서는 SQLite API를 직접 사용하는 `android.database.sqlite`(SQLiteOpenHelper)와 이를 좀 더 세련되게 도와주는 `Room`에 대해 정리한다.  
간단한 전화번호부 앱을 만들어서 `SQLiteOpenHelper`를 이용한 방법과 `Room`을 이용하는 방법으로 진행되며 레이아웃은 다음과 같다. 

![]({{ site.url }}/assets/images/65-1.png ){: .align-center width="70%" height="50%"}

```xml
<!-- activity_main.xml -->

<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity">

    <EditText
        android:id="@+id/nameEditText"
        android:layout_width="200dp"
        android:layout_height="wrap_content"
        android:layout_marginTop="20dp"
        android:hint="이름"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" />

    <EditText
        android:id="@+id/phoneNumberEditText"
        android:layout_width="200dp"
        android:layout_height="wrap_content"
        android:layout_marginTop="10dp"
        android:hint="전화번호"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf="@id/nameEditText" />

    <Button
        android:id="@+id/addButton"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_marginTop="10dp"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf="@id/phoneNumberEditText"
        android:text="추가"
         />

    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/phoneBookRecyclerView"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf="@id/addButton"
        app:layout_constraintBottom_toBottomOf="parent"
         />

</androidx.constraintlayout.widget.ConstraintLayout>
```

## SQLiteOpenHelper
먼저 SQL 데이터베이스의 스키마를 체계적으로 관리하기 위해 계약 클래스를 만들자. 계약 클래스는 URI, 테이블 및 열의 이름을 정의하는 상수를 관리하는 클래스이다. 계약 클래스를 통해 동일한 패키지의 다른 모든 클래스에 동일한 상수를 사용할 수 있다. 계약 클래스를 구성하는 방법은 루트 수준에 있는 데이터베이스 전체에 전역적인 정의를 추가하는 것이다. 그런 다음 각 테이블의 내부를 구성한다.  

```kotlin
// PhoneBookContract
import android.provider.BaseColumns

object PhoneBookContract {
    object PhoneBookEntry : BaseColumns {
        const val TABLE_NAME = "phone_book"
        const val NAME = "name"
        const val PHONE_NUMBER = "phone_number"
    }

    private const val SQL_CREATE_ENTRIES =
        "CREATE TABLE ${PhoneBookEntry.TABLE_NAME} (" +
                "${BaseColumns._ID} INTEGER PRIMARY KEY," +
                "${PhoneBookEntry.NAME} TEXT," +
                "${PhoneBookEntry.PHONE_NUMBER} TEXT)"

    private const val SQL_DELETE_ENTRIES = "DROP TABLE IF EXISTS ${PhoneBookEntry.TABLE_NAME}"
}
```

다음으로 데이터베이스 및 테이블의 CRUD를 관리해야 한다. 이러한 기능을 처리하기 위해 `SQLiteOpenHelper`를 사용한다. 또한 `SQLiteOpenHelper`에는 데이터베이스 관리를 위한 유용한 API들을 포함하고 있다. 개발자는 필요에 따라 `getWritableDatabase()`, `getReadableDatabase()`를 호출하며 데이터베이스 참조를 가져와서 작업을 처리할 수 있다.  

`SQLiteOpenHelper`를 사용하려면 `onCreate()` 및 `onUpgrade()` 콜백 메소드를 재정의하는 서브클래스를 생성해야 한다. 이 외에도 `onDowngrade()` 또는 `onOpen()` 메소드를 구현할 수도 있다.  

이름과 번호를 입력받아 데이터베이스에 추가하는 `insert()`와 전체 데이터를 가져오는 `getAll()` 메소드도 다음과 같이 만들자. 

```kotlin
// PhoneBookDbHelper

import android.content.Context
import android.database.sqlite.SQLiteDatabase
import android.database.sqlite.SQLiteOpenHelper
import com.example.app_database_test.PhoneBookContract.CREATE_ENTRIES
import com.example.app_database_test.PhoneBookContract.DELETE_ENTRIES

class PhoneBookDbHelper(context: Context) :
    SQLiteOpenHelper(context, DATABASE_NAME, null, DATABASE_VERSION) {

    companion object {
        const val DATABASE_VERSION = 1
        const val DATABASE_NAME = "phone_book.db"
    }

    override fun onCreate(db: SQLiteDatabase?) {
        db?.execSQL(CREATE_ENTRIES)
    }

    override fun onUpgrade(db: SQLiteDatabase?, oldVersion: Int, newVersion: Int) {
        db?.execSQL(DELETE_ENTRIES)
        onCreate(db)
    }

    fun insert(name: String, phoneNumber: String) {
        val db = this.writableDatabase
        val values = ContentValues().apply {
            put(PhoneBookEntry.NAME, name)
            put(PhoneBookEntry.PHONE_NUMBER, phoneNumber)
        }
        db?.insert(PhoneBookEntry.TABLE_NAME, null, values)
    }

    fun getAll() : List<Contact> {
        val db = this.readableDatabase
        val cursor = db.query(PhoneBookEntry.TABLE_NAME, null, null,
            null, null, null, null)
        val contactList = arrayListOf<Contact>()
        with(cursor) {
            while (moveToNext()) {
                val id = cursor.getInt(0)
                val name = cursor.getString(1)
                val phoneNumber = cursor.getString(2)
                contactList.add(Contact(id, name, phoneNumber))
            }
        }
        return contactList
    }
}
```

`getAll()`의 리턴 값으로 사용되는 `Contact` 데이터 클래스는 다음과 같다.

```kotlin
// Contact
import java.util.*

data class Contact(val id: Int, val name: String, val phoneNumber: String) {
    override fun equals(other: Any?): Boolean {
        (other as? Contact)?.let {
            return this.id == other.id
        } ?: return super.equals(other)
    }

    override fun hashCode(): Int {
        return Objects.hash(this.id)
    }
}
```

여기서는 데이터베이스의 적용을 확인하는 용도로 사용하므로 리사이클러 뷰와 어댑터에 관한 설명은 생략한다. MainActivity에서는 `추가` 버튼에 이름과 번호를 데이터베이스에 저장하고 데이터베이스에 있는 데이터를 화면에 띄우는 작업을 하는 리스너를 달아준다.

```kotlin
// MainActivity
import android.os.Bundle
import androidx.appcompat.app.AppCompatActivity
import androidx.recyclerview.widget.LinearLayoutManager
import kotlinx.android.synthetic.main.activity_main.*

class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        init()
    }

    private fun init() {
        val dbHelper = PhoneBookDbHelper(this)

        phoneBookRecyclerView.layoutManager = LinearLayoutManager(this)
        val adapter = ContactListAdapter()
        adapter.submitList(dbHelper.getAll())
        phoneBookRecyclerView.adapter = adapter

        addButton.setOnClickListener {
            dbHelper.insert(nameEditText.text.toString(), phoneNumberEditText.text.toString())
            nameEditText.text.clear()
            phoneNumberEditText.text.clear()
            adapter.submitList(dbHelper.getAll())
        }
    }
}
```

결과는 다음과 같다. 

![]({{ site.url }}/assets/images/65-2.gif ){: .align-center width="70%" height="50%"}

다른 쿼리들도 공식 문서를 참고해서 하면 쉽게 따라할 수 있을 것이다. 물론 로우 쿼리를 직접 날릴 수도 있다. 그러나 안드로이드 공식문서에서는 앱 내부 `SQLite`에 접근할 때는 다음과 같은 이유로 `Room`을 이용할 것을 권장하고 있다. 

> 주의: 이러한 API는 강력하기는 하지만 상당히 낮은 수준이므로 다음과 같이 사용하는 데 상당한 시간과 노력이 필요합니다.
- 원시 SQL 쿼리에 관한 컴파일 시간 확인이 없습니다. 따라서 데이터 그래프가 변경됨에 따라 영향을 받는 SQL 쿼리를 수동으로 업데이트해야 합니다. 이 과정은 시간이 오래 걸리고 오류가 쉽게 발생할 수 있습니다.
- SQL 쿼리와 데이터 객체 간에 변환하려면 많은 상용구 코드를 사용해야 합니다.
이러한 이유 때문에 앱의 SQLite 데이터베이스에 있는 정보에 액세스하기 위한 추상화 레이어로 Room 지속성 라이브러리를 사용하는 것이 좋습니다.

## Room





<br>
<br>