---
title: "[Django] Django의 애플리케이션 개발 방식"
excerpt: "Django의 애플리케이션 개발 방식"
toc: true
toc_sticky: true
categories: [Web]
tags: [Web, Django, Python, Pycharm, Application, MVT]
---

## MVT 패턴
Django는 기존의 MVC 패턴의 개념을 그대로 받아 들인 MVT 패턴을 사용하고 있다. <br>

<!-- <table style = "margin-left: auto; margin-right: auto;">
    <th>기존</th>
    <th>Django</th>
    <tr><td align = "center">Model</td><td align = "center">Model</td></tr>
    <tr><td align = "center">View</td><td align = "center">Template</td></tr>
    <tr><td align = "center">Controller</td><td align = "center">View</td></tr>
</table> -->


| 기존 | 장고 |
|:---------:|:---------:|
| Model | Model |
| View  | Template  |
| Controller    | View  |

- Model: DB에 저장되는 데이터를 의미한다.
- View: 실질적으로 프로그램 로직이 동작하여 데이터를 가져오고 적절하게 처리한 결과를 템플릿에 전달하는 역할을 한다.
- Template: 사용자에게 보여지는 UI를 처리한다.

<br>

| ![]({{ site.url }}/assets/images/d-a-0.png ){: .align-center} |
|:--:|
| *Django의 MVT 패턴* |

<br>

웹 클라이언트의 요청을 받고, 장고에서 MVT 패턴에 따라 처리하는 과정을 요약하면 다음과 같다.
1. 클라이언트로부터 요청을 받으면 URLconf를 이용하여 URL을 분석한다.
2. URL 분석 결과를 통해 URL에 대한 처리를 담당할 뷰를 결정한다.
3. 뷰는 자신의 로직을 실행하면서 만약 DB 처리가 필요하면 모델을 통해 처리하고 그 결과를 반환받는다.
4. 뷰는 자신의 로직 처리가 끝나면 템플릿을 사용하여 클라이언트에 전송할 HTML 파일을 생성한다.
5. 뷰는 최종 결과로 HTML 파일을 클라이언트에게 보내 응답한다.

<br>
<br>

## Model - DB 정의
모델이란 사용될 데이터에 대한 정의를 담고 있는 장고의 클래스이다. <br>
장고는 ORM 기법을 사용하여 애플리케이션에서 사용할 DB를 클래스로 매핑해서 코딩할 수 있다. <br>
즉, 하나의 모델 클래스는 하나의 테이블에 매핑되고, 모델 클래스의 속성은 테이블의 컬럼에 매핑된다. <br> <br>

이렇게 ORM 기법을 사용하여 테이블을 클래스로 매핑하면, 애플리케이션에서는 DB에 대한 액세스를 SQL 없이도 클래스를 다루는 것처럼 할 수 있어서 편리하다. <br> 또한 SQLite3, MySQL, PostgreSQL 등 DB 엔진을 변경하더라도 ORM을 통한 API는 변경할 필요가 없기 때문에, 필요에 따라 DB 엔진을 훨씬 쉽게 변경할 수 있다. <br>

> ORM 대한 개념은 [여기](https://jayzzz.tistory.com/66)를 참고하자.

<br>

models.py에 다음과 같은 Person를 정의해 보자.
```python
from django.db import models

class Person(models.Model):
	first_name = models.CharField(max_length=30)
last_name = models.CharField(max_length=30)
```
<br>
Person 모델은 Django 내부적으로 SQL 명령을 사용하여 다음과 같은 DB 테이블을 생성한다.
```sql
CREATE TABLE myapp_person (
    "id" serial NOT NULL PRIMARY KEY,
    "first_name" varchar(30) NOT NULL,
    "last_name" varchar(30) NOT NULL
);
```
<br>

장고는 테이블 및 컬럼을 자동으로 생성하기 위해 필요한 많은 규칙을 갖고 있다. 위의 예제는 그 중에서 다음과 같은 규칙이 적용된 것이다.
- 테이블은 에플리케이션명과 모델 클래스명을 `_`로 연결하고, 모두 소문자로 표시한다. 원한다면 다른 이름으로 직접 지정할 수도 있다.
- Primary Key는 Person 클래스에서 정의하지 않아도 장고에서 자동으로 부여한다. 개발자가 직접 지정할 수 있다.
- 그 밖의 내용은 [여기](https://docS.djangoprojecT.com/en/2.1/topics/db/models/)를 참고하자.

장고는 테이블을 모델 클래스로 정의하고 이를 실제 DB에 반영한 후에도 테이블에 데이터를 입력하고 입력된 데이터를 확인 및 변경할 수 있는 여러 가지 기능을 제공한다.
<br>
<br>

## URLconf
클라이언트로부터 요청을 받으면 장고는 가장 먼저 요청에 들어있는 URL을 분석한다. <br>
즉 요청에 들어있는 URL이 urls.py 파일에 정의된 URL 패턴과 매칭되는지를 분석한다. <br><br>

파이썬의 URL 정의 방식은 전통적인 자바나 PHP 계열의 URL보다 직관적이고 이해가기가 쉽다. <br> 
URL을 정의하기 위해서는 다음 예제처럼 urls.py 파일에 URL과 처리 함수(View)를 매핑하는 파이썬 코드를 작성하면 된다. <br>
이러한 URL/View 매핑을 URLconf라고 한다. <br>

``` python
from django.urls import path

from . import views

urlpatterns = [
    path('articles/2003/', views.special_case_2003),
    path('articles/<int:year>', views.year_archive),
    path('articles/<int:year>/<int:month>/', views.month_archive),
    path('articles/<int:year>/<int:month>/<slug:slug>', views.article_detail),
]
```

위 예시에서 articles/2003/ 부분이 URL이고 views.special_case2003 부분이 처리 함수(뷰)이다. <br>
<br>

이와 같이 URL과 처리 함수를 별도로 정의하고, 이 둘을 매핑하는 방법은 개발자에게 많은 유연성을 제공한다. <br>
URL 자체에 처리 함수나 처리용 스크립트 파일 이름이 들어가면 변경이 어려워지기 때문이다. <br>
반면 URLconf를 사용하면 URL과 뷰 함수를 서로 자유롭게 연결할 수 있어서 규모가 큰 프로젝트를 개발할 때처럼 URL과 뷰 함수 이름이 자주 바뀌는 경우에도 URLconf에서 매핑한 부분만 수정하면 되므로 변경이 쉬워진다.<br>

웹 클라이언트가 웹 서버에 페이지 요청 시, 장고에서 URL을 분석하는 순서를 간단히 요약하면 다음과 같다.
1. settings.py 파일의 ROOT_URLCONF 항목을 읽어 최상위 URLconf(urls.py)의 위치를 파악
2. URLconf를 로딩하여 urlpatterns 변수에 지정되어 있는 URL 리스트를 검사
3. 위에서부터 순서대로 URL 리스트의 내용을 검사하면서 URL 패턴이 매치되면 검사를 종료
4. 매치된 URL의 View를 호출한다. 여기서 View는 함수 또는 클래스의 메소드이다. 호출 시 HttpRequest 객체와 매칭될 때 추출된 단어들을 View에 인자로 넘겨 줌
5. URL 리스트 끝까지 검사했는데도 매칭에 실패하면 에러를 처리하는 View를 호출

위의 예시에서 URL 패턴을 정의할 때 `<>`를 사용하는 부분이 있다. <br>
이는 URL 패턴의 일부 문자열을 추출하기 위한 것이며, `<type:name>` 형식으로 사용한다. <br>

`path('articles/<int:year>/', views.year_archive),`

이 라인의 의미는 요청 URL이 `/articles/2020/`처럼 `<>` 부분이 정수이면 매치되고 `/articles/foo/`처럼 정수가 아니면 매치되지 않는다. <br>
또한 매치된 경우에는 매치된 문자열 `2020`을 문자열 `year`에 할당한다. <br>
즉, 요청 URL이 `/articles/2020/`이면 뷰 함수를 `views.year_archive(request, year=2020)`처럼 호출한다. <br>

`<>`를 Path Converter라고 부르는데, 여기에 사용되는 타입은 다음과 같다.
- str: `/`를 제외한 모든 문자열과 매치됨. 타입을 지정하지 않았다면 디폴트로 str 타입을 사용함.
- int: 0 또는 양의 정수와 매치됨. 매치된 정수는 파이썬의 int 타입으로 변환됨.
- slug: <acronym title="ASCII, 숫자, 하이픈, 밑줄로만 구성">slug 형식의 문자열</acronym>과 매치됨.
- uuid: UUID 형식의 문자열과 매치됨. 매치된 문자열을 파이썬의 UUID 타입으로 변환됨.
- path: `/`를 포함한 모든 문자열과 매치됨. 이는 URL 패턴의 일부가 아니라 전체를 추출하고자 할 때 많이 사용

<br>
URL 패턴에 정규표현식<sub>Regular Expression</sub>을 사용하면 URL을 좀 더 세밀하게 표현하거나, 복잡한 URL도 표현할 수가 있다. 예를 들어 정규표현식을 사용하여 앞서의 예시와 동일한 URL 패턴을 작성하면 다음과 같다.

```python
from django.urls import path

from . import views

urlpatterns = [
    path('articles/2003/', views.special_case_2003),
    re_path(r'^articles/(?P<year>[0-9]{4})/$', views.year_archive),
    re_path(r'^articles/(?P<year>[0-9]{4})/(?P<month>[0-9]{2})/$', views.month_archive),
    re_path(r'^articles/(?P<year>[0-9]{4})/(?P<month>[0-9]{2})/(?P<slug>[\w-]+)/$', views.article_detail),
]
```
<br>

`path()` 함수에서의 <int:year> 부분이 `re_path()` 함수에서는 `(?P<year>[0-9]{4})`처럼 정규표현식을 사용하면서, 모든 정수가 아니라 `0-9`로 이뤄진 4자리 숫자만 매치되도록 한정하고 있다. <br>
보통은 `path()` 함수를 많이 사용하고, URL을 좀 더 정교하게 정의하고자 할 때는 `re_path()` 함수와 정규표현식을 사용한다.

<br>
<br>

## View

## Template

## MVT 코딩 순서