---
title: "[Algorithm] Inversion Counting"
excerpt: "역순의 개수를 구하는 알고리즘 Inversion Counting을 알아보자."
toc: true
toc_sticky: true
categories: [Algorithm]
tags: [Algorithm, Inversion Counting, Merge Sort, 1517번, 10090번]
use_math: true
---

## Inversion Counting
수열에서 자신보다 앞에 있는 숫자 중 자신보다 큰 수를 inversion이라 하는데 그러한 inversion의 개수를 세는 알고리즘이다. <br>
브루트 포스로 접근하면 $O(N^2)$인데 머지소트를 응용하면 $O(NlogN)$으로 해결할 수 있다.

## Merge Sort
수열 $A$에서 $i < j$이며 $A_i$ > $A_j$인 쌍들의 개수를 찾는 문제이다. <br>
머지 소트의 정렬 과정에서 $A_i <= A_j$의 조건으로 정렬되는 부분을 빼면 나머지 부분은 $A_i > $A_j$를 만족하는 구간이다. <br>
따라서 나머지 부분의 개수가 inversion의 개수이다.

## 문제
<details>
<summary p style="cursor:pointer">[10090번: Counting Inversions]</summary>
<div markdown="1">

<br>

<https://www.acmicpc.net/problem/10090>

<br>
머지 소트를 진행하면서 $A_i > A_j$을 만족하는 부분의 개수를 더해준다.

<details>
<summary p style="cursor:pointer">코드</summary>
<div markdown="1">

```java
import java.io.*;
import java.util.*;

public class Main {

    static FastIO io = new FastIO();
    static int N;
    static long res;
    static int[] arr, sorted;

    public static void main(String... args) throws IOException {
        N = io.nextInt();
        arr = new int[N]; sorted = new int[N];
        for (int i = 0; i < N; i++) {
            arr[i] = io.nextInt();
        }

        mergeSort(0, N - 1);

        io.write(res);
    }

    private static void merge(int s, int m, int e) {
        int i = s, j = m + 1, k = s;

        while (i <= m && j <= e) {
            if (arr[i] <= arr[j])
                sorted[k++] = arr[i++];
            else {
                sorted[k++] = arr[j++];
                res += m - i + 1;
            }
        }

        while (i <= m) {
            sorted[k++] = arr[i++];
        }

        while (j <= e) {
            sorted[k++] = arr[j++];
        }

        while (s <= e) {
            arr[s] = sorted[s++];
        }
    }

    private static void mergeSort(int s, int e) {
        if (s < e) {
            int m = (s + e) >>> 1;
            mergeSort(s, m);
            mergeSort(m + 1, e);
            merge(s, m, e);
        }
    }
}

class FastIO { ... }	// 생략
```

</div>
</details>

</div>
</details>

<br>
<br>

<details>
<summary p style="cursor:pointer">[1517번: 버블 소트]</summary>
<div markdown="1">

<br>

<https://www.acmicpc.net/problem/1517>

<br>
N이 최대 500000이기 때문에 향상된 버블 소트를 구현해서 카운팅을 하는 방법으로는 해결할 수 없다. 마찬가지로 머지 소트의 진행과정에서 카운트를 해서 $O(NlogN)$에 해결할 수 있다.

<details>
<summary p style="cursor:pointer">코드</summary>
<div markdown="1">

```java
import java.io.*;
import java.util.*;

public class Main {

    static FastIO io = new FastIO();
    static int N;
    static long res;
    static int[] arr, sorted;

    public static void main(String... args) throws IOException {
        N = io.nextInt();
        arr = new int[N]; sorted = new int[N];
        for (int i = 0; i < N; i++) {
            arr[i] = io.nextInt();
        }

        mergeSort(0, N - 1);

        io.write(res);
    }

    private static void merge(int s, int m, int e) {
        int i = s, j = m + 1, k = s;

        while (i <= m && j <= e) {
            if (arr[i] <= arr[j])
                sorted[k++] = arr[i++];
            else {
                sorted[k++] = arr[j++];
                res += m - i + 1;
            }
        }

        while (i <= m) {
            sorted[k++] = arr[i++];
        }

        while (j <= e) {
            sorted[k++] = arr[j++];
        }

        while (s <= e) {
            arr[s] = sorted[s++];
        }
    }

    private static void mergeSort(int s, int e) {
        if (s < e) {
            int m = (s + e) >>> 1;
            mergeSort(s, m);
            mergeSort(m + 1, e);
            merge(s, m, e);
        }
    }
}

class FastIO { ... }	// 생략
```

</div>
</details>

</div>
</details>

<br>
<br>