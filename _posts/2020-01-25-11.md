---
title: "[Algorithm] Lower Bound와 Upper Bound"
excerpt: "원소의 위치를 정하는 Lower Bound와 Upper Bound 알고리즘을 알아보자."
toc: true
toc_sticky: true
categories: [Algorithm]
tags: [Algorithm, Lower Bound, Upper Bound, 이분탐색]
use_math: true
---

## 개요
Lower Bound와 Upper Bound는 이분 탐색에서 파생된 알고리즘으로 원소가 들어갈 위치를 $O(logN)$으로 찾는다. <br> 
Lower Bound는 **원하는 값 k 이상이 처음 나오는 위치**를 찾는 알고리즘이며, Upper Bound는 **원하는 값 k보다 큰 값이 처음 나오는 위치**를 찾는 알고리즘이다.

## Lower Bound
Lower Bound는 이분 탐색 기반이므로 오름차순으로 정렬이 되어 있어야 한다. 같은 원소가 여러개 있어도 상관 없으며 항상 유일한 해를 구할 수 있다. <br>
Lower Bound는 찾으려 하는 원소가 없으면 찾으려 하는 원소보다 큰 가장 작은 원소의 위치를 찾는다.

1. 배열 arr이 있을 때 구간 $[low, high]$에서 중간의 위치를 $m$이라 하자.
2. $arr[m-1] < element$이면서 $arr[m] >= element$인 최소의 m을 찾으면 된다.

<br>

```java
private static int lowerBound(int[] arr, int low, int high, int element) {
    while (low < high) {
        int m = (low + high) / 2;
        if (arr[m] < element)
            low = m + 1;
        else
            high = m;
    }	
    return low;
}
```

<details>
<summary p style="cursor.pointer">[11053번: 가장 긴 증가하는 부분 수열]</summary>
<div markdown="1">

<br>

<https://www.acmicpc.net/problem/11053>

<br>
LIS는 2차원 for문으로 $O(N^2)$ DP로 해결할 수도 있지만 Lower Bound를 통해 $O(N^2)$을 $O(NlogN)$으로 낮출 수 있다. 

<details>
<summary p style="cursor.pointer">코드</summary>
<div markdown="1">

```java
import java.io.*;
import java.util.*;

public class Main {

    static FastIO io = new FastIO();
    static int[] arr, dp;
    
    public static void main(String... args) throws IOException {
        int N = io.nextInt();
        arr = new int[N + 1];   dp = new int[N + 1];
        for (int i = 1; i < N + 1; i++) {
            arr[i] = io.nextInt();
        }

        dp[1] = arr[1];
        int idx = 1;
        for (int i = 2; i < N + 1; i++) {
            if (dp[idx] < arr[i])
                dp[++idx] = arr[i];
            else
                dp[lowerBound(dp, 0, idx, arr[i])] = arr[i];
        }

        io.write(idx);
    }
    
    private static int lowerBound(int[] arr, int low, int high, int element) {
        while (low < high) {
            int m = (low + high) / 2;
            if (arr[m] < element)
                low = m + 1;
            else
                high = m;
        }
        return low;
    }

}

class FastIO { ... }	// 생략
```

</div>
</details>



</div>
</details>

<br>
<br>

## Upper Bound
Upper Bound도 Lower Bound와 마찬가지로 오름차순으로 정렬이 되어 있어야 하며 같은 원소가 여러개 있어도 상관 없으며 항상 유일한 해를 구할 수 있다. <br>
Upper Bound는 찾으려는 원소를 초과하는 가장 첫 번째 원소의 위치를 찾는다.

1. 배열 arr이 있을 때 구간 $[low, high]$에서 중간의 위치를 $m$이라 하자.
2. $arr[m-1] <= element$이면서 $arr[m] > element$인 최소의 m을 찾으면 된다.

<br>

```java
private static int upperBound(int[] arr, int low, int high, int element) {
	while (low < high) {
		int m = (low + high) / 2;
		if (arr[m] <= element)
			low = m + 1;
		else
			high = m;
	}
	return low;
}
```


<br>
<br>